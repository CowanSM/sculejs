/**
 * Copyright (c) 2013, Dan Eyles (dan@irlgaming.com)
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of IRL Gaming nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL IRL Gaming BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
"use strict";

/**
 * @module com.scule.db.vm
 * @private
 * @type {Object}
 */
module.exports = {
    Scule: {
        functions: {},
        classes: {},
        instructions: {
            table: {},
            mapping: {},
            index: {}
        },
        variables: {
            line: 0,
            inst: 0
        },
        constants: require(__dirname + '/com.scule.constants'),
        $f: require(__dirname + '/com.scule.functions').Scule.functions,
        $d: require(__dirname + '/com.scule.datastructures')
    }
};

/**
 * A hybrid (stack + registers) virtual machine that executes programs 
 * written in Scule bytecode. The generated bytecode is subroutine threaded
 * @see http://en.wikipedia.org/wiki/Threaded_code#Subroutine_threading
 * @public
 * @constructor
 * @class {VirtualMachine}
 * @returns {Void}
 */
module.exports.Scule.classes.VirtualMachine = function () {
    
    /**
     * @private
     * @type {Boolean}
     */
    this.running      = false;
   
    /**
     * @private
     * @type {Boolean}
     */   
    this.upsert       = false;
    
    /**
     * The program instruction pointer
     * @private
     * @type {Number}
     */    
    this.ipointer     = 0;
    
    /**
     * The program document pointer
     * @private
     * @type {Number}
     */    
    this.dpointer     = 0;
    
    /**
     * The random access registers for the machine
     * @private
     * @type {Array}
     */    
    this.registers    = [];
    
    /**
     * @private
     * @type {Object}
     */    
    this.instructions = {};
    
    /**
     * The execution stack for the machine
     * @private
     * @type {LIFOStack}
     */    
    this.stack        = module.exports.Scule.$d.getLIFOStack();
    
    /**
     * @private
     * @type {Array}
     */    
    this.result       = [];
    
    /**
     * Resets the state of the virtual machine
     * @public
     * @returns {Void}
     */
    this.reset = function () {
        this.running   = false;
        this.upsert    = false;
        this.ipointer  = 0;
        this.dpointer  = 0;
        this.registers = [];
        this.result    = [];
        this.stack.clear();
    };
    
    /**
     * Halts execution
     * @public
     * @returns {Void}
     */
    this.halt = function () {
        this.running = false;
    };
    
    /**
     * Resumes execution
     * @public
     * @returns {Void}
     */
    this.resume = function () {
        this.running = true;
        this.execute();
    };    
    
    /**
     * Executes the provided bytecode program
     * @public
     * @see http://en.wikipedia.org/wiki/Upsert
     * @param {Array} program the bytecode query program instructions to execute
     * @param {Array} mutate the bytecode mutate program instructions to execute
     * @param {Boolean} upsert a boolean flag indicating whether or not to perform upserts
     * @returns {Array}
     */
    this.execute = function (program, mutate, upsert) {
        if (!program) {
            program = this.registers[3];
        } else {
            this.registers[3] = program;
        }
        
        this.running = true;
        while (this.running) {
            this.executeInstruction(program[this.ipointer]);
        }
        this.running = false;
        
        if (mutate) {
            this.dpointer = 0;
            this.ipointer = 0;
            this.running  = true;
            this.upsert   = upsert;
            while (this.running) {
                this.executeInstruction(mutate[this.ipointer]);
            }
        }
        
        return this.result;
    };
    
    /**
     * Registers an instruction with the Scule virtual machine
     * @public
     * @param {Integer} opcode the bytecode opcode to register the sub-routine against
     * @param {Function} macro the sub-routine code to register
     * @returns {Void}
     */
    this.registerInstruction = function (opcode, macro) {
        this.instructions[opcode] = macro;
    };
    
    /**
     * halt
     */
    this.registerInstruction(0x00, function (vm, instruction) {
        vm.running = false;
        vm.ipointer++;
    });
    
    /**
     * break
     */
    this.registerInstruction(0x1A, function (vm, instruction) {
        vm.running = false;
        vm.ipointer++;
    });
    
    /**
     * start
     */
    this.registerInstruction(0x24, function (vm, instruction) {
        vm.running = true;
        vm.ipointer++;
    });
    
    /**
     * scan
     */
    this.registerInstruction(0x1C, function (vm, instruction) {
        var o = instruction[1][0].findAll();
        if (o.length === 0) {
            vm.running = false;
        }
        vm.stack.push(o);
        vm.ipointer++;
    });
    
    /**
     * range
     */
    this.registerInstruction(0x1D, function (vm, instruction) {
        var args = instruction[1][1];
        vm.stack.push(instruction[1][0].range(args[0], args[1], args[2], args[3]));
        vm.ipointer++;       
    });
    
    /**
     * find
     */
    this.registerInstruction(0x1B, function (vm, instruction) {
        vm.stack.push(instruction[1][0].search(instruction[1][1]));
        vm.ipointer++;
    });
    
    /**
     * store
     */
    this.registerInstruction(0x21, function (vm, instruction) {
        vm.registers[0] = vm.stack.pop();
        vm.ipointer++;
    });
    
    /**
     * transpose
     */
    this.registerInstruction(0x28, function (vm, instruction) {
        vm.result = vm.registers[0];
        vm.ipointer++;
    });
    
    /**
     * read
     */
    this.registerInstruction(0x27, function (vm, instruction) {
        vm.registers[1] = vm.registers[0][vm.dpointer];
        vm.dpointer++;
        vm.ipointer++;
    });
    
    /**
     * shift
     */
    this.registerInstruction(0x20, function (vm, instruction) {
        if (vm.stack.pop() === true) {
            vm.result.push(vm.registers[1]);
        }
        vm.ipointer++;
    });
    
    /**
     * intersect
     */
    this.registerInstruction(0x23, function (vm, instruction) {
        if (vm.stack.getLength() == 1) {
            vm.ipointer++;
            return;
        }
        var arrays = [];
        while (!vm.stack.isEmpty()) {
            arrays.push(vm.stack.pop());
        }
        var result = module.exports.Scule.functions.intersection(arrays);
        if (result.length === 0) {
            vm.running = false;
        }
        vm.stack.push(result);
        vm.ipointer++;
    });
    
    /**
     * and
     */
    this.registerInstruction(0x01, function (vm, instruction) {
        var count = instruction[1][0];
        var and   = null;
        do {
            if (and === null) {
                and = vm.stack.pop();
            } else {
                and = and && vm.stack.pop();
            }
            count--;
        } while (count > 0);
        vm.stack.push(and);
        vm.ipointer++;
    });    

    /**
     * or
     */
    this.registerInstruction(0x02, function (vm, instruction) {
        var count = instruction[1][0];
        var or    = null;
        do {
            if (or === null) {
                or = vm.stack.pop();
            } else {
                or = or || vm.stack.pop();
            }
            count--;
        } while (count > 0);
        vm.stack.push(or);
        vm.ipointer++;
    });
    
    /**
     * goto
     */
    this.registerInstruction(0x26, function (vm, instruction) {
        vm.ipointer = instruction[1][0];
    });
    
    /**
     * jump
     */
    this.registerInstruction(0x25, function (vm, instruction) {
        if (vm.dpointer >= vm.registers[0].length) {
            vm.ipointer = instruction[1][0];
            return;
        }
        vm.ipointer++;
    });
    
    /**
     * eq
     */
    this.registerInstruction(0xC, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        if (instruction[1][1] instanceof RegExp) {
            vm.stack.push(instruction[1][1].test(value));
        } else {
            vm.stack.push(value == instruction[1][1]);
        }
        vm.ipointer++;
    });
    
    /**
     * ne
     */
    this.registerInstruction(0xD, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        vm.stack.push(value !== instruction[1][1]);
        vm.ipointer++;        
    });
    
    /**
     * gt
     */
    this.registerInstruction(0x07, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        vm.stack.push(value > instruction[1][1]);
        vm.ipointer++;        
    });

    /**
     * gte
     */
    this.registerInstruction(0x08, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        vm.stack.push(value >= instruction[1][1]);
        vm.ipointer++;        
    });

    /**
     * lt
     */
    this.registerInstruction(0x05, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        vm.stack.push(value < instruction[1][1]);
        vm.ipointer++;        
    });

    /**
     * lte
     */
    this.registerInstruction(0x06, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        vm.stack.push(value <= instruction[1][1]);
        vm.ipointer++;        
    });

    /**
     * in
     */
    this.registerInstruction(0xA, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        if (value === undefined) {
            vm.stack.push(false);
        } else {
            vm.stack.push(instruction[1][1].contains(value));
        }
        vm.ipointer++;
    });

    /**
     * nin
     */
    this.registerInstruction(0xB, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        if (value === undefined) {
            vm.stack.push(true);
        } else {
            vm.stack.push(!instruction[1][1].contains(value));
        }
        vm.ipointer++;
    });

    /**
     * size
     */
    this.registerInstruction(0xE, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        vm.stack.push(module.exports.Scule.$f.sizeOf(value) == instruction[1][1]);
        vm.ipointer++;
    });

    /**
     * exists
     */
    this.registerInstruction(0xF, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        if (instruction[1][1]) {
            vm.stack.push(value !== undefined);
        } else {
            vm.stack.push(value === undefined);
        }        
        vm.ipointer++;
    });

    /**
     * all
     */
    this.registerInstruction(0x09, function (vm, instruction) {
        var object = vm.registers[1];
        var value  = module.exports.Scule.$f.traverse(instruction[1][0], object);
        if (!module.exports.Scule.$f.isArray(value)) {
            vm.stack.push(false);
        } else {
            var table = instruction[1][1];
            if (value.length < table.getLength()) {
                vm.stack.push(false);
            } else {
                var tmp  = module.exports.Scule.$d.getHashTable();
                var keys = table.getKeys();
                keys.forEach(function (key) {
                    tmp.put(key, false);
                });
                for (var i=0; i < value.length; i++) {
                    if (tmp.contains(value[i])) {
                        tmp.remove(value[i]);
                    }
                }
                vm.stack.push(tmp.getLength() === 0);
            }
        }
        vm.ipointer++;
    });
    
    /**
     * sort
     */
    this.registerInstruction(0x2A, function (vm, instruction) {
        module.exports.Scule.$f.sort(instruction[1][1], vm.result, instruction[1][0]);
        vm.ipointer++;
    });

    /**
     * skip
     */
    this.registerInstruction(0x2D, function (vm, instruction) {
        var skip = instruction[1][0];
        var len  = vm.result.length;
        if (instruction[1][0] >= len) {
            vm.result = [];
        } else {
            vm.result.splice(0, skip);
        }
        vm.ipointer++;
    });

    /**
     * limit
     */
    this.registerInstruction(0x29, function (vm, instruction) {
        if (instruction[1][0] < vm.result.length) {
            vm.result = vm.result.splice(0, instruction[1][0]);
        }
        vm.ipointer++;
    });

    /**
     * rread
     */
    this.registerInstruction(0x2B, function (vm, instruction) {
        if (vm.dpointer >= vm.result.length) {
            vm.halt();
        }
        vm.registers[1] = vm.result[vm.dpointer];
        vm.dpointer++;
        vm.ipointer++;        
    });

    /**
     * set
     */
    this.registerInstruction(0x12, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (!(leaf in o)) {
            if (vm.upsert === true) {
                o[leaf] = instruction[1][1];
            }
        } else {
            o[leaf] = instruction[1][1];
        }
        vm.ipointer++;
    });

    /**
     * unset
     */
    this.registerInstruction(0x13, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (leaf in o) {
            delete o[leaf];
        }
        vm.ipointer++;        
    });

    /**
     * inc
     */
    this.registerInstruction(0x14, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (!(leaf in o)) {
            if (vm.upsert) {
                o[leaf] = instruction[1][1];
            }
        } else {
            if (module.exports.Scule.$f.isInteger(o[leaf]) || module.exports.Scule.$f.isDouble(o[leaf])) {
                o[leaf] += instruction[1][1];   
            }
        }
        vm.ipointer++;        
    });

    /**
     * opull
     */
    this.registerInstruction(0x15, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (leaf in o && module.exports.Scule.$f.isArray(o[leaf])) {
            var val = instruction[1][1];
            for (var i=0; i < o[leaf].length; i++) {
                if (o[leaf][i] == val) {
                    o[leaf].splice(i, 1);
                    i--;
                }
            }  
        }
        vm.ipointer++;         
    });

    /**
     * opullall
     */
    this.registerInstruction(0x16, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (leaf in o && module.exports.Scule.$f.isArray(o[leaf])) {
            var value = instruction[1][1];
            if (!module.exports.Scule.$f.isArray(value)) {
                throw 'the $pullAll operator requires an associated array as an operand';
            }
            var table = module.exports.Scule.$d.getHashTable();
            value.forEach(function (val) {
                table.put(val, true); 
            });
            for (var i=0; i < o[leaf].length; i++) {
                if (table.contains(o[leaf][i])) {
                    o[leaf].splice(i, 1);
                    i--;
                }
            }  
        }
        vm.ipointer++;         
    });

    /**
     * opop
     */
    this.registerInstruction(0x17, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (leaf in o && module.exports.Scule.$f.isArray(o[leaf])) {
            o[leaf].pop();   
        }
        vm.ipointer++;        
    });
    
    /**
     * opush
     */
    this.registerInstruction(0x18, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (!(leaf in o) && vm.upsert) {
            o[leaf] = instruction[1][1];
        } else {
            if (module.exports.Scule.$f.isArray(o[leaf])) {
                o[leaf].push(instruction[1][1]);   
            }
        }
        vm.ipointer++;        
    });
    
    /**
     * opushall
     */
    this.registerInstruction(0x19, function (vm, instruction) {
        var document = vm.registers[1];
        var struct   = module.exports.Scule.$f.traverseObject(instruction[1][0], document);
        var leaf     = struct[0];
        var o        = struct[1];
        if (!(leaf in o) && vm.upsert) {
            o[leaf] = instruction[1][1];
        } else {
            var value = instruction[1][1];
            if (!module.exports.Scule.$f.isArray(value)) {
                throw 'the $pushAll operator requires an associated array as an operand';
            }            
            if (module.exports.Scule.$f.isArray(o[leaf])) {
                o[leaf] = o[leaf].concat(value);   
            }
        }
        vm.ipointer++;         
    });

    /**
     * rindex
     */
    this.registerInstruction(0x2C, function (vm, instruction) {
        module.exports.Scule.functions.updateIndexes(vm.registers[1], instruction[1][0]);
        vm.ipointer++;
    });

    /**
     * within
     */
    this.registerInstruction(0x10, function (vm, instruction) {
        var document = vm.registers[1];
        var loc1     = module.exports.Scule.$f.traverseObject(module.exports.Scule.$f.parseAttributes(instruction[1][0]), document);
        if (loc1.length < 2 || !('loc' in loc1[1])) {
            vm.stack.push(false);
        } else {        
            loc1 = loc1[1].loc;
            if (!('lat' in loc1) || !('lon' in loc1)) {
                vm.stack.push(false);
            } else {
                var loc2 = instruction[1][1];
                var d    = Math.sqrt(Math.pow(loc2.lat - loc1.lat, 2) + Math.pow(loc2.lon - loc1.lon, 2));
                if (d <= loc2.distance) {
                    document = module.exports.Scule.$f.cloneObject(document);
                    document._meta = {
                        distance: d
                    };
                    vm.registers[1] = document;                
                    vm.stack.push(true);
                } else {
                    vm.stack.push(false);
                }
            }
        }
        vm.ipointer++;        
    });

    /**
     * near
     */
    this.registerInstruction(0x11, function (vm, instruction) {
        var document = vm.registers[1];
        var loc1     = module.exports.Scule.$f.traverseObject(module.exports.Scule.$f.parseAttributes(instruction[1][0]), document);
        if (loc1.length < 2 || !('loc' in loc1[1])) {
            vm.stack.push(false);
        } else {
            loc1         = loc1[1].loc;
            var loc2     = instruction[1][1];
            var distance = loc2.distance;
            if (!('lat' in loc1) || !('lon' in loc1)) {
                vm.stack.push(false);
            } else {
                var d = Math.acos(Math.sin(loc1.lat) * Math.sin(loc2.lat) + Math.cos(loc1.lat) * Math.cos(loc2.lat) * Math.cos(loc2.lon - loc1.lon)) * 6371;
                if (d <= distance) {
                    document = module.exports.Scule.$f.cloneObject(document);
                    document._meta = {
                        distance: d
                    };
                    vm.registers[1] = document;
                    vm.stack.push(true);
                } else {
                    vm.stack.push(false);
                }
            }
        }
        vm.ipointer++;
    });

    /**
     * Executes a bytecode instruction
     * @public
     * @param {Array} instruction the instruction to execute
     * @returns {Void}
     */
    this.executeInstruction = function (instruction) {
        this.instructions[instruction[0]](this, instruction);
    };
    
};

/**
 * Updates all indices for a collection with a given document
 * @param {Object} document the document to update indices for
 * @param {Collection} collection the collection encapsulating the indices to update
 * @returns {Void}
 */
module.exports.Scule.functions.updateIndexes = function (document, collection) {
    collection.indices.forEach(function (index) {
        index.remove(document);
        index.index(document);
    });
};

/**
 * Calculates the intersection between the provided array of Document arrays, returning
 * an array containing the resulting product
 * @param {Array} lists an array containing the lists to calculate intersection against
 * @returns {Array}
 */
module.exports.Scule.functions.intersection = function (lists) {
    if (lists.length == 1) {
        return lists[0];
    }
    var table = module.exports.Scule.$d.getHashTable();
    var list  = null;
    lists.forEach(function (o) {
        if (!list || o.length < list.length) {
            list = o;
        }
    });
    if (!list) {
        return [];
    }    
    list.forEach(function (o) {
        table.put(module.exports.Scule.$f.getObjectId(o), {
            c:1, 
            o:o
        });
    });
    var intersection = [];
    var len = lists.length;
    for (var i=0; i < len; i++) {
        if (lists[i] == list) {
            continue;
        }
        var func = function (o) {
            var o2 = table.get(module.exports.Scule.$f.getObjectId(o));
            if (o2) {
                o2.c++;
                if (o2.c == len) {
                    intersection.push(o);
                }
            }
        };
        lists[i].forEach(func);
    }
    return intersection;
};

/**
 * Returns an instance of the {VirtualMachine} class
 * @returns {VirtualMachine}
 */
module.exports.getVirtualMachine = function () {
    return new module.exports.Scule.classes.VirtualMachine();
};